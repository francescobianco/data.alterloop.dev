Genera un file Apps Script che trasformi uno spreadsheet in una DB via API

prendi nota del fatto che input delle doGet e doPost sono di questa forma

GET:
{
  "parameter": {
    "sheet": "2025",
    "$REMOTE_ADDRESS": "81.56.115.230",
    "$REQUEST_URI": "/list",
    "$USER_AGENT": "curl/7.87.0"
  },
  "contentLength": -1,
  "parameters": {
    "$REQUEST_URI": [
      "/list"
    ],
    "$REMOTE_ADDRESS": [
      "81.56.115.230"
    ],
    "$USER_AGENT": [
      "curl/7.87.0"
    ],
    "sheet": [
      "2025"
    ]
  },
  "contextPath": "",
  "queryString": "$REMOTE_ADDRESS=81.56.115.230&$USER_AGENT=curl%2F7.87.0&$REQUEST_URI=%2Flist&sheet=2025"
}

POST:
{
  "contentLength": 37,
  "contextPath": "",
  "queryString": "$REMOTE_ADDRESS=185.2.23.188&$USER_AGENT=curl%2F8.5.0&$REQUEST_URI=%2Finsert",
  "postData": {
    "contents": "{\"sheet\":\"Test CIAO\", \"name\":\"Frank\"}",
    "length": 37,
    "name": "postData",
    "type": "application/json"
  },
  "parameters": {
    "$USER_AGENT": [
      "curl/8.5.0"
    ],
    "$REQUEST_URI": [
      "/insert"
    ],
    "$REMOTE_ADDRESS": [
      "185.2.23.188"
    ]
  },
  "parameter": {
    "$USER_AGENT": "curl/8.5.0",
    "$REQUEST_URI": "/insert",
    "$REMOTE_ADDRESS": "185.2.23.188"
  }
}

dobbiamo implementare le seguenti api

GET /list
POST /insert
POST /update
POST /delete

ecco come deve apparira la risposta di ogni chiamata

GET /list
Response: {
  "sheet": "2025",
  "columns": ["name", "age"],
  "data": [
	{
	  "name": "Frank",
	  "age": 25
	},
	{
	  "name": "John",
	  "age": 30
	}
  ]
}

POST /insert
Response: {
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
  		  "sheet": "2025",
  		  "row": 2
		  "name": "Frank",
		  "age": 25
		  }
  ]
}

POST /update
Response: {
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
  		"sheet": "2025",
  		"row": 2,
		  "name": "Frank",
		  "age": 25
		  }
  ]
}

POST /delete
Response: {
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
  		"sheet": "2025",
  		"row": 25,
		  "name": "Frank",
		  "age": 25
		  }
  ]
}


Ecco alcuni casi di test

GET /list?sheet=2025
GET /list?sheet=2025&row=2

ricorda le seguenti feature

- quando uno sheet non viene trovato in scrittura (solo in insert) deve essere creato
- quando uno sheet non viene esplicitato si fa riferimento al primo sheet disponibile
- tutti i messaggi devono essere scritti in inglese
- assicurati che la getOrCreateSheet sia chiamata solo nella api di insert
- assicurati che la creazione dello sheet funzioni verificando che sia stato creato
- restituisci nella response il nome dello sheet manipolato in una chiave a parte della response questo deve servire come conferma che lo sheet selezionato sia quello corretto
- ricorda che lo sheet su cui agire nel caso GET e un parametro in di querystring nel caso post e un parametro nel body della richiesta JSON
- nel caso POST lo sheetname da modificare o creare si trova nel payload JSON del body quindi devi prenderlo con e.postData.contents.sheet
- ricorda che per ogni oggetto inserito o aggioranto nella tabella devono essere agguinte le colonne per ospitare i nuovi dati
- l'oggetto json in ingesso deve essere esploso in campi radice e e i campi sotto la radice devono essere appiattivi con la notazione '.'
- assicurati dopo l'inserimento di verificare che il record sia effettivamente presente quindi facendo dopo la append una read dell'ultimo rigo e contronllare i due valori
- nel codice ci deve essere una funzione updateHeaders che si occupa di aggiornare l'header della tabella con i nuovi campi deve sempre fare il merge tra quanto gia esiste fare la diff con quelli del nuovo oggetto da inserire o aggiornare e poi aggiornare la prima riga
- attenzione nella insert e nella update la proprieta sheet è una chiave e non deve essere inserita come colonna o aggiornata quindi non ci sara mail la colonna sheet, attenzione però che data in risposta lo sheet ci deve essere quindi deve essere rimosso proprio in prossimita della chiamata concreta appendRow
- stai attento a togliere nel merge delle colonne iniziali eventuali colonne vuote quando il foglio e vuoto
- un altro campo chiave da trattare come lo sheet e il row che riporta il numero di riga per come visibile nello spreadsheet quello ci deve essere sempre
- i record ritornati nella response data non devono essere flatten ma strutturati e devono contenere anche le colonne che in input non ho mandato
- ricordati che i record in response data devono sempre contenere la chiave sheet e row
- nella GET tutte le chiave del query string che non iniziano per $ sono considerate colonne da filtrare es. ?city.name=Palermo significa che voglio solo i record dove la colonna city.name e appunto Palermo
- assicurati che delete funzioni su piu righe e che restituisca i record cancellati considera che le chiavi possono essere quelle libere passate nel postData quindi se voglio cancellare passero qualcosa simile ha {"sheet":"2025","row":2}

ecco un implementazione di riferimento

/**
 * Handle GET requests
 * Expected URL format:
 *   /list?sheet=SheetName&$REMOTE_ADDRESS=...&$USER_AGENT=...&$REQUEST_URI=/list
 *
 * Response example:
 * {
 *   "sheet": "2025",
 *   "columns": ["name", "age"],
 *   "data": [
 *     { "name": "Frank", "age": 25, "row": 2 },
 *     { "name": "John", "age": 30, "row": 3 }
 *   ]
 * }
 *
 * @param {Object} e - Event object
 * @return {TextOutput} JSON response
 */
function doGet(e) {
  try {
    var action = extractAction(e);
    var sheetName = extractSheetNameFromGet(e);
    var sheet = getSheet(sheetName);
    if (!sheet) {
      return outputJSON({ error: "Sheet not found", sheet: sheetName });
    }

    if (action === "list") {
      var dataObj = readData(sheet);
      return outputJSON({
        sheet: sheet.getName(),
        columns: dataObj.columns,
        data: dataObj.data
      });
    }
    return outputJSON({ error: "Invalid action", sheet: sheetName });
  } catch (error) {
    return outputJSON({ error: "Error processing request: " + error.message });
  }
}

/**
 * Handle POST requests
 *
 * Expected payload examples:
 * For insert:
 *   { "sheet": "Test CIAO", "name": "Frank", "age": 25 }
 *
 * For update:
 *   { "sheet": "2025", "filter": { "name": "Frank" }, "data": { "age": 30 } }
 *
 * For delete:
 *   { "sheet": "2025", "filter": { "name": "Frank" } }
 *
 * The response always returns the full, structured record (with all columns and a "row" key).
 *
 * @param {Object} e - Event object
 * @return {TextOutput} JSON response
 */
function doPost(e) {
  try {
    var action = extractAction(e);

    // Parse and flatten the JSON payload
    var params;
    try {
      params = JSON.parse(e.postData.contents);
    } catch (error) {
      return outputJSON({ error: "Invalid JSON data" });
    }
    params = flattenObject(params);

    // For POST, the sheet name is provided in the JSON payload ("sheet")
    var sheetName = params.sheet || getFirstSheetName();
    // Remove the 'sheet' key so it is not inserted/updated as a column.
    delete params.sheet;
    if (params.data) {
      delete params.data.sheet;
    }
    if (params.filter) {
      delete params.filter.sheet;
    }

    var sheet;
    if (action === "insert") {
      sheet = getOrCreateSheet(sheetName);
    } else {
      sheet = getSheet(sheetName);
    }
    if (!sheet) {
      return outputJSON({ error: "Sheet not found", sheet: sheetName });
    }

    if (action === "insert") {
      var result = insertData(sheet, params);
      return outputJSON({
        sheet: sheet.getName(),
        columns: result.columns,
        success: result.success,
        data: [result.inserted]
      });
    }

    if (action === "update") {
      var result = updateData(sheet, params);
      return outputJSON({
        sheet: sheet.getName(),
        columns: result.columns,
        success: result.success,
        data: [result.updated]
      });
    }

    if (action === "delete") {
      var result = deleteData(sheet, params);
      return outputJSON({
        sheet: sheet.getName(),
        columns: result.columns,
        success: result.success,
        data: [result.deleted]
      });
    }

    return outputJSON({ error: "Invalid action", sheet: sheetName });
  } catch (error) {
    return outputJSON({ error: "Error processing request: " + error.message });
  }
}

/**
 * Extract the API action from the $REQUEST_URI parameter.
 * For example, "/list" becomes "list".
 * @param {Object} e - Event object
 * @returns {string} Action string
 */
function extractAction(e) {
  var uri = e.parameter && e.parameter["$REQUEST_URI"];
  if (uri) {
    if (typeof uri === "string") {
      return uri.substring(1); // remove the leading '/'
    } else if (uri instanceof Array) {
      return uri[0].substring(1);
    }
  }
  return "";
}

/**
 * Extract sheet name for GET requests from query parameters.
 * @param {Object} e - Event object
 * @returns {string} Sheet name
 */
function extractSheetNameFromGet(e) {
  if (e.parameter && e.parameter.sheet) {
    if (typeof e.parameter.sheet === "string") {
      return e.parameter.sheet;
    } else if (e.parameter.sheet instanceof Array) {
      return e.parameter.sheet[0];
    }
  }
  return getFirstSheetName();
}

/**
 * Returns the name of the first sheet.
 * @returns {string} Sheet name
 */
function getFirstSheetName() {
  return SpreadsheetApp.getActiveSpreadsheet().getSheets()[0].getName();
}

/**
 * Get sheet by name.
 * @param {string} sheetName
 * @returns {Sheet} Spreadsheet sheet
 */
function getSheet(sheetName) {
  return SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
}

/**
 * Get or create a sheet. Only used in the insert API.
 * @param {string} sheetName
 * @returns {Sheet} Spreadsheet sheet
 */
function getOrCreateSheet(sheetName) {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    if (!sheet) throw new Error("Failed to create sheet: " + sheetName);
  }
  return sheet;
}

/**
 * Read all data from the sheet.
 * Returns an object with header ("columns") and row data ("data").
 * Each record is built from the sheet's row, includes a "row" property with the actual row number,
 * and is unflattened (structured) so that any keys with dot-notation become nested objects.
 *
 * @param {Sheet} sheet
 * @returns {Object} Data object { columns: Array, data: Array }
 */
function readData(sheet) {
  var data = sheet.getDataRange().getValues();
  if (data.length < 1) return { columns: [], data: [] };
  // Remove empty columns from the header row
  var headers = data[0].filter(function(h) { return h !== ""; });
  var result = [];
  for (var i = 1; i < data.length; i++) {
    var flatObj = {};
    for (var j = 0; j < headers.length; j++) {
      flatObj[headers[j]] = data[i][j];
    }
    // Add the actual spreadsheet row number
    flatObj["row"] = i + 1;
    // Convert the flat object into a structured (nested) object
    result.push(unflattenObject(flatObj));
  }
  return { columns: headers, data: result };
}

/**
 * Flatten a nested object using dot notation.
 * For example: { a: { b: "value" } } becomes { "a.b": "value" }.
 *
 * @param {Object} obj - The object to flatten.
 * @param {string} [prefix] - The prefix for nested keys.
 * @returns {Object} The flattened object.
 */
function flattenObject(obj, prefix) {
  var result = {};
  prefix = prefix ? prefix + "." : "";
  for (var key in obj) {
    if (!obj.hasOwnProperty(key)) continue;
    if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
      var flatObject = flattenObject(obj[key], prefix + key);
      for (var subKey in flatObject) {
        if (flatObject.hasOwnProperty(subKey)) {
          result[subKey] = flatObject[subKey];
        }
      }
    } else {
      result[prefix + key] = obj[key];
    }
  }
  return result;
}

/**
 * Unflatten a flat object with dot notation into a nested object.
 *
 * @param {Object} data - The flat object.
 * @returns {Object} The structured (nested) object.
 */
function unflattenObject(data) {
  var result = {};
  for (var key in data) {
    if (!data.hasOwnProperty(key)) continue;
    var parts = key.split('.');
    var current = result;
    for (var i = 0; i < parts.length; i++) {
      if (i === parts.length - 1) {
        current[parts[i]] = data[key];
      } else {
        if (current[parts[i]] === undefined) {
          current[parts[i]] = {};
        }
        current = current[parts[i]];
      }
    }
  }
  return result;
}

/**
 * Update the header row of the sheet to include new keys from the newData.
 * Merges existing headers with the keys in newData, filtering out any empty columns.
 * The keys "sheet" and "row" are ignored.
 *
 * @param {Sheet} sheet - The target sheet.
 * @param {Object} newData - The new data object.
 * @returns {Array} Updated headers array.
 */
function updateHeaders(sheet, newData) {
  var range = sheet.getDataRange();
  var values = range.getValues();
  var headers = [];
  if (values.length > 0) {
    headers = values[0].filter(function(h) { return h !== ""; });
  }
  var headerSet = {};
  for (var i = 0; i < headers.length; i++) {
    headerSet[headers[i]] = true;
  }
  var newKeys = Object.keys(newData).filter(function(key) {
    return key !== "sheet" && key !== "row";
  });
  var updated = false;
  for (var i = 0; i < newKeys.length; i++) {
    if (!headerSet[newKeys[i]]) {
      headers.push(newKeys[i]);
      headerSet[newKeys[i]] = true;
      updated = true;
    }
  }
  if (updated || values.length === 0) {
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  }
  return headers;
}

/**
 * Insert a record into the sheet.
 * This function updates headers, appends the new row, verifies the insertion,
 * and then returns the full structured record (including the "row" number).
 *
 * @param {Sheet} sheet - The target sheet.
 * @param {Object} record - The flattened record to insert.
 * @returns {Object} Result object with inserted record, success flag, and columns.
 */
function insertData(sheet, record) {
  var headers = updateHeaders(sheet, record);
  var row = headers.map(function(header) {
    return record[header] !== undefined ? record[header] : "";
  });
  sheet.appendRow(row);
  var lastRow = sheet.getLastRow();
  var insertedValues = sheet.getRange(lastRow, 1, 1, headers.length).getValues()[0];
  var flatInserted = {};
  for (var i = 0; i < headers.length; i++) {
    flatInserted[headers[i]] = insertedValues[i];
  }
  flatInserted["row"] = lastRow;
  var structured = unflattenObject(flatInserted);

  // Verify insertion by comparing the inserted row values.
  var verified = true;
  for (var i = 0; i < headers.length; i++) {
    if (row[i] != insertedValues[i]) {
      verified = false;
      break;
    }
  }
  return { success: verified, inserted: structured, columns: headers };
}

/**
 * Update a record in the sheet.
 * Expects the parameters to include:
 *   - filter: an object containing the key-value pair to locate the row.
 *   - data: an object with new data to update.
 * Returns the full structured updated record (including the "row" number).
 *
 * @param {Sheet} sheet - The target sheet.
 * @param {Object} params - Contains 'filter' and 'data'.
 * @returns {Object} Result object with updated record, success flag, and columns.
 */
function updateData(sheet, params) {
  if (!params.filter || !params.data) {
    return { error: "Update requires 'filter' and 'data' parameters", success: false, columns: [] };
  }
  var newData = flattenObject(params.data);
  var headers = updateHeaders(sheet, newData);
  var data = sheet.getDataRange().getValues();
  if (data.length < 1) return { error: "Sheet is empty", success: false, columns: headers };

  var filterKey = Object.keys(params.filter)[0];
  var filterValue = params.filter[filterKey];
  var filterIndex = headers.indexOf(filterKey);
  if (filterIndex === -1) return { error: "Filter column not found", success: false, columns: headers };

  var updatedRowIndex = null;
  for (var i = 1; i < data.length; i++) {
    if (data[i][filterIndex] == filterValue) {
      updatedRowIndex = i + 1;
      for (var j = 0; j < headers.length; j++) {
        if (newData[headers[j]] !== undefined) {
          sheet.getRange(i + 1, j + 1).setValue(newData[headers[j]]);
        }
      }
      break;
    }
  }
  if (updatedRowIndex === null) return { error: "Row not found", success: false, columns: headers };

  var updatedValues = sheet.getRange(updatedRowIndex, 1, 1, headers.length).getValues()[0];
  var flatUpdated = {};
  for (var i = 0; i < headers.length; i++) {
    flatUpdated[headers[i]] = updatedValues[i];
  }
  flatUpdated["row"] = updatedRowIndex;
  var structured = unflattenObject(flatUpdated);
  return { success: true, updated: structured, columns: headers };
}

/**
 * Delete a record from the sheet.
 * Expects the parameters to include a filter object.
 * Returns the full structured deleted record (including the "row" number).
 *
 * @param {Sheet} sheet - The target sheet.
 * @param {Object} params - Contains 'filter'.
 * @returns {Object} Result object with deleted record, success flag, and columns.
 */
function deleteData(sheet, params) {
  if (!params.filter) {
    return { error: "Delete requires 'filter' parameter", success: false, columns: [] };
  }
  var data = sheet.getDataRange().getValues();
  if (data.length < 1) return { error: "Sheet is empty", success: false, columns: [] };
  var headers = data[0].filter(function(h) { return h !== ""; });
  var filterKey = Object.keys(params.filter)[0];
  var filterValue = params.filter[filterKey];
  var filterIndex = headers.indexOf(filterKey);
  if (filterIndex === -1) return { error: "Filter column not found", success: false, columns: headers };

  for (var i = data.length - 1; i > 0; i--) {
    if (data[i][filterIndex] == filterValue) {
      var deletedFlat = {};
      for (var j = 0; j < headers.length; j++) {
        deletedFlat[headers[j]] = data[i][j];
      }
      deletedFlat["row"] = i + 1;
      sheet.deleteRow(i + 1);
      var structured = unflattenObject(deletedFlat);
      return { success: true, deleted: structured, columns: headers };
    }
  }
  return { error: "Row not found", success: false, columns: headers };
}

/**
 * Helper function to output JSON response.
 *
 * @param {Object} data - The data to output.
 * @returns {TextOutput} ContentService JSON output.
 */
function outputJSON(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}
