Genera un file Apps Script che trasformi uno spreadsheet in una DB via API

prendi nota del fatto che input delle doGet e doPost sono di questa forma

GET:
{
  "parameter": {
    "sheet": "2025",
    "$REMOTE_ADDRESS": "81.56.115.230",
    "$REQUEST_URI": "/list",
    "$USER_AGENT": "curl/7.87.0"
  },
  "contentLength": -1,
  "parameters": {
    "$REQUEST_URI": [
      "/list"
    ],
    "$REMOTE_ADDRESS": [
      "81.56.115.230"
    ],
    "$USER_AGENT": [
      "curl/7.87.0"
    ],
    "sheet": [
      "2025"
    ]
  },
  "contextPath": "",
  "queryString": "$REMOTE_ADDRESS=81.56.115.230&$USER_AGENT=curl%2F7.87.0&$REQUEST_URI=%2Flist&sheet=2025"
}

POST:
{
  "contentLength": 37,
  "contextPath": "",
  "queryString": "$REMOTE_ADDRESS=185.2.23.188&$USER_AGENT=curl%2F8.5.0&$REQUEST_URI=%2Finsert",
  "postData": {
    "contents": "{\"sheet\":\"Test CIAO\", \"name\":\"Frank\"}",
    "length": 37,
    "name": "postData",
    "type": "application/json"
  },
  "parameters": {
    "$USER_AGENT": [
      "curl/8.5.0"
    ],
    "$REQUEST_URI": [
      "/insert"
    ],
    "$REMOTE_ADDRESS": [
      "185.2.23.188"
    ]
  },
  "parameter": {
    "$USER_AGENT": "curl/8.5.0",
    "$REQUEST_URI": "/insert",
    "$REMOTE_ADDRESS": "185.2.23.188"
  }
}

dobbiamo implementare le seguenti api

GET /list
POST /insert
POST /update
POST /delete

ecco come deve apparira la risposta di ogni chiamata

GET /list
{
  "sheet": "2025",
  "columns": ["name", "age"],
  "data": [
	{
	  "name": "Frank",
	  "age": 25
	},
	{
	  "name": "John",
	  "age": 30
	}
  ]
}

POST /insert
{
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
		  "name": "Frank",
		  "age": 25
		  }
  ]
}

POST /update
{
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
		  "name": "Frank",
		  "age": 25
		  }
  ]
}

POST /delete
{
  "sheet": "2025",
  "columns": ["name", "age"],
  "success": true,
  "data": [
  		{
		  "name": "Frank",
		  "age": 25
		  }
  ]
}


ricorda le seguenti feature

- quando uno sheet non viene trovato in scrittura (solo in insert) deve essere creato
- quando uno sheet non viene esplicitato si fa riferimento al primo sheet disponibile
- tutti i messaggi devono essere scritti in inglese
- assicurati che la getOrCreateSheet sia chiamata solo nella api di insert
- assicurati che la creazione dello sheet funzioni verificando che sia stato creato
- restituisci nella response il nome dello sheet manipolato in una chiave a parte della response questo deve servire come conferma che lo sheet selezionato sia quello corretto
- ricorda che lo sheet su cui agire nel caso GET e un parametro in di querystring nel caso post e un parametro nel body della richiesta JSON
- nel caso POST lo scheetname da modificare o creare si trova nel payload JSON del body quindi devi prenderlo con e.postData.contents.sheet
- ricorda che per ogni oggetto inserito o aggioranto nella tabella devono essere agguinte le colonne per ospitare i nuovi dati
- l'oggetto json in ingesso deve essere esposo in campi radice e e i campi sotto la radice devono essere appiattivi con la notazione '.'
- assicurati dopo l'inserimento di veridicare che il record sia effettivametne presente quindi facendo dopo la append una read dell'ultimo rigo e contronllare i due valori

ecco un implementazione di riferimento

/**
 * Handle GET requests
 * @param {Object} e - Event object
 * @return {TextOutput} JSON response
 */
function doGet(e) {
  try {
    const action = extractAction(e);
    const sheetName = extractSheetName(e);
    const sheet = getSheet(sheetName);

    if (!sheet) return outputJSON({ error: "Sheet not found", sheet: sheetName });

    if (action === "list") return outputJSON({ sheet: sheetName, data: readData(sheet) });

    return outputJSON({ error: "Invalid action", sheet: sheetName });
  } catch (error) {
    return outputJSON({ error: "Error processing request: " + error.message });
  }
}

/**
 * Handle POST requests
 * @param {Object} e - Event object
 * @return {TextOutput} JSON response
 */
function doPost(e) {
  try {
    const action = extractAction(e);
    const sheetName = extractSheetName(e);
    let sheet = action === "insert" ? getOrCreateSheet(sheetName) : getSheet(sheetName);

    if (!sheet) return outputJSON({ error: "Sheet not found", sheet: sheetName });

    let params;
    try {
      params = JSON.parse(e.postData.contents);
    } catch (error) {
      return outputJSON({ error: "Invalid JSON data", sheet: sheetName });
    }

    if (action === "insert") return outputJSON({ sheet: sheetName, result: insertData(sheet, params) });
    if (action === "update") return outputJSON({ sheet: sheetName, result: updateData(sheet, params) });
    if (action === "delete") return outputJSON({ sheet: sheetName, result: deleteData(sheet, params) });

    return outputJSON({ error: "Invalid action", sheet: sheetName });
  } catch (error) {
    return outputJSON({ error: "Error processing request: " + error.message });
  }
}

function extractAction(e) {
  return e.parameter?.["$REQUEST_URI"]?.substring(1) || "";
}

function extractSheetName(e) {
  return e.parameter?.sheet?.[0] || getFirstSheetName();
}

function getFirstSheetName() {
  return SpreadsheetApp.getActiveSpreadsheet().getSheets()[0].getName();
}

function getSheet(sheetName) {
  return SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
}

function getOrCreateSheet(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    if (!sheet) throw new Error("Failed to create sheet");
  }
  return sheet;
}

function readData(sheet) {
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) return [];
  const headers = data.shift();
  return data.map(row => Object.fromEntries(headers.map((h, i) => [h, row[i]])));
}

function insertData(sheet, newData) {
  const headers = sheet.getDataRange().getValues()[0] || Object.keys(newData);
  if (sheet.getLastRow() === 0) sheet.appendRow(headers);
  sheet.appendRow(headers.map(h => newData[h] ?? ""));
  return { success: true, inserted: newData };
}

function updateData(sheet, params) {
  if (!params.filter || !params.data) return { error: "Update requires 'filter' and 'data' parameters" };
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const filterKey = Object.keys(params.filter)[0];
  const filterIndex = headers.indexOf(filterKey);
  if (filterIndex === -1) return { error: "Filter column not found" };

  for (let i = 1; i < data.length; i++) {
    if (data[i][filterIndex] == params.filter[filterKey]) {
      headers.forEach((h, j) => {
        if (params.data[h] !== undefined) sheet.getRange(i + 1, j + 1).setValue(params.data[h]);
      });
      return { success: true, updated: params.data };
    }
  }
  return { error: "Row not found" };
}

function deleteData(sheet, params) {
  if (!params.filter) return { error: "Delete requires 'filter' parameter" };
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const filterKey = Object.keys(params.filter)[0];
  const filterIndex = headers.indexOf(filterKey);
  if (filterIndex === -1) return { error: "Filter column not found" };

  for (let i = data.length - 1; i > 0; i--) {
    if (data[i][filterIndex] == params.filter[filterKey]) {
      sheet.deleteRow(i + 1);
      return { success: true, deleted: params.filter };
    }
  }
  return { error: "Row not found" };
}

function outputJSON(data) {
  return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
}